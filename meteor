#!/usr/bin/env bash

BUNDLE_VERSION=8.2.5

UNAME=$(uname)
ARCH="$(uname -m)"
PLATFORM="${UNAME}_${ARCH}"

# Find the script dir, following symlinks. Note that symlink can be relative or
# absolute. Too bad 'readlink -f' and 'realpath' (the command-line program) are
# not portable.  We don't stress about infinite loops or bad links, because the
# OS has already resolved this symlink chain once in order to actually run the
# shell script.
ORIG_DIR="$(pwd)"
SCRIPT="$0"
while true; do
  # The symlink might be relative, so we have to actually cd to the right place
  # each time in order to resolve it.
  cd "$(dirname "$SCRIPT")"
  if [ ! -L "$(basename "$SCRIPT")" ]; then
    SCRIPT_DIR="$(pwd -P)"
    break
  fi
  SCRIPT="$(readlink "$(basename "$SCRIPT")")"
done
cd "$ORIG_DIR"

export BABEL_CACHE_DIR="$SCRIPT_DIR/.babel-cache"
DEV_BUNDLE="$SCRIPT_DIR/dev_bundle"
METEOR="$SCRIPT_DIR/tools/index.js"

# Set the nofile ulimit as high as permitted by the hard-limit/kernel
if [ "$(ulimit -Sn)" != "unlimited" ]; then
    maxfilesuse="$(ulimit -Hn)"
    if [ -n "${maxfilesuse}" ] && [ "${maxfilesuse}" != "unlimited" ]; then
        ulimit -Sn ${maxfilesuse} > /dev/null 2>&1
    fi
fi

# We used to set $NODE_PATH here to include the node_modules from the dev
# bundle, but now we just get them from the symlink at tools/node_modules. This
# is better because node_modules directories found via the ancestor walk from
# the script take precedence over $NODE_PATH; it used to be that users would
# screw up their meteor installs by have a ~/node_modules

exec "/usr/bin/node" \
     --expose-gc \
     ${TOOL_NODE_FLAGS} \
     "$METEOR" "$@"
